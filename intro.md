---
layout: code
title: Intro to Blog
---

## Why Clojure

{% highlight clojure %}

(+ 3 (* 8 6))

{% endhighlight %}

I've played with Clojure on and off for the last few months. It is an excellent language,
and I recently had the pleasure of using it to re-implement a project from my Object
Oriented Design class I took this last semester. My feeling is that some of the design
patterns we learned were not really necessary---that they do not in fact cut to the
essence of the underlying abstractions. 

These are some things that I want to explore: Abstractions, the limitations of different
programming paradigms, and the challenges of designing, implementing and extending the
mythical beast we call the *large system*.

I am not interested in Clojure merely as a pretty mathematical abstraction. If we cannot
actually use our tools to make real software more effectively, then the abstractions
we claim are valuable have not proven themselves. This goes back to the principle of 
science needing to make predictions. The analogue here is that theories and paradigms of
software need to actually make us more effective. The generalized idea here is that we 
need to make [our beliefs pay rent]
(http://lesswrong.com/lw/i3/making_beliefs_pay_rent_in_anticipated_experiences/).
The particular rent we seek is greater rates of chanelling, growing and understanding.
These are the primary metrics that will help us judge if the elegant is more than 
just idle abstraction. 
